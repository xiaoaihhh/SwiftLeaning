//
//  Initialization.swift
//  SwiftLeaningKit
//
//  Created by fanshuaifei on 2021/5/22.
//  Copyright © 2021 SwiftLeaning. All rights reserved.
//

import Foundation

struct InitializationTest: Runable {
    static func run() {
        print("\n\n=================== Initialization ====================")
        initializerDefineTest()
        defaultInitializersTest()
        
    }
    
    /// 构造过程是使用类、结构体或枚举类型实例之前的准备过程，在新实例使用之前，必须为每个存储属性设置初始值和执行其它必须的设置工作。与 Objective-C 中的构造器不同，Swift 的构造器没有返回值，它的主要任务是保证某种类型的新实例在第一次使用前完成正确的初始化。
    
    /// 创建类和结构体实例时，必须为所有存储型属性设置合初始值。可以在构造器中设置初始值，或者在定义属性时设置默认值，这两种方式的值是直接设置的，不会触发属性观察者。
    
    
    /// 构造器的定义
    static func initializerDefineTest() {
        class SomeClass {
            // 非可选类型的存储属性必须在构造器或者定义时候设置初始值；可选类型的存储属性表示可以被设置为 nil，可以不在构造器或者定义时候设置默认值，因为默认为 nil。
            var x: Double = 0.0 // 定义时设置默认值
            var y: Int // 在构造器中设置初始值
            var z: String? // 可选类型的存储属性，默认初始化为 nil
            var i: String? = "i" // 可选类型的存储属性也可以设置默认值
            
            // 常量属性被赋值后将永远不可改变
            let j: Int = 10 // 常量也可以在定义时候设置初始值； 由于常量只能初始化一次，因此 j 不能在次在构造器中初始化。
            let k: Float // 常量也可以在构造器中设置初始值
            
            /// 构造器的参数列表定义方式和函数的参数列表定义一模一样，可以指定形参名字和实参标签名字，也可以省略实参标签
            
            // 由于只有 y 和 k 是非可选存储属性且没有设置默认值，因此构造器中必须设置 y 的初始值
            init() {
                y = 0
                k = 0
                // j = 0 // 编译报错，j 是常量，并且在定义时已经初始化，不能在初始化第二次
            }
            
            init(y: Int, k: Float) {
                self.y = y
                self.k = k
            }
            
            init(x: Double, y y0: Int, _ z: String?, i: String, k: Float) {
                self.x = x
                self.y = y0
                self.z = z
                self.i = i
                self.k = k
            }
        }
        
        class SomeSubClass: SomeClass {
            var m: Int
            
            override init() {
                // y = 0 //  编译报错，父类的成员属性必须在父类的构造器中完成初始化
                
                // 1. 必须先完成本身成员属性初始化
                m = 10
                // 2. 然后调用父类构造器，完成父类成员属性初始化
                super.init()
                
                // 1 和 2 完成后可以修改父类成员属性，如果是常量属性，由于是在父类完成构造后不能改变，因此不能在子类中修改。
                y = 10
            }
        }
    }
    
    
    /// 默认构造器
    /// 如果结构体或类为所有属性提供了默认值，又没有提供任何自定义的构造器，那么 Swift 会给这些结构体或类提供一个默认构造器。这个默认构造器将简单地创建一个所有属性值都设置为它们默认值的实例。
    static func defaultInitializersTest() {
        // 所有成员均有默认值，因此有一个默认构造器
        class SomeClass {
            let x = 10
            var y = 0
            var z: Int?
        }
        let _ = SomeClass()
        
        /// 结构体逐一成员构造器（memberwise initializer），为没有初始化值的属性生成一个默认的逐一成员构造器（包含可选成员）
        /// 1. 变量设置了默认值，逐一成员构造器参数列表中可以包含这个参数，也可以不包含这个参数;
        /// 2. 常量设置了默认值，逐一成员构造器参数列表中一定不包含这个参数
        /// 3. 不设置默认值（常量、变量、可选类型）逐一成员构造器参数列表中一定包含这个参数
        struct SomeStruct {
            let x: Int
            var y = 0 // 变量设置了默认值，逐一成员构造器参数列表中可以包含这个参数，也可以不包含这个参数;
            let z: Int?
            let i: String
            var j = 0 // 变量设置了默认值，逐一成员构造器参数列表中可以包含这个参数，也可以不包含这个参数;
            let k = 0 // 常量设置默认值，逐一成员构造器参数列表中一定不包含这个参数
        }
        let _ = SomeStruct(x: 10, z: 10, i: "i")
        let _ = SomeStruct(x: 10, z: 10, i: "i", j: 10)
        let _ = SomeStruct(x: 10, y: 10, z: 10, i: "i")
        let _ = SomeStruct(x: 10, y: 10, z: 10, i: "i", j: 10)
        
        /// 如果提供了自定义的构造器，则不会生成逐一成员构造器和默认构造器（对于类，如果提供了自定义构造器，则不会生成默认构造器，因为类没有逐一成员构造器）
        struct SomeStruct1 {
            var x = 0
            var y = 0
            init(y: Int) {
                self.y = y
            }
        }
        // let _ = SomeStruct1(x:0, y: 0) // 编译报错，没有生成逐一成员构造器
        // let _ = SomeStruct1() // 编译报错，没有生成默认构造器
        let _ = SomeStruct1(y: 0)
        
        /// 如果是在扩展中提供了自定义构造器，不影响生成默认构造器和逐一成员构造器，具体可以见扩展部分
    }
    
    
    /// 构造器可以通过调用其它构造器来完成实例的部分构造过程，这一过程称为构造器代理，它能避免多个构造器间的代码重复。
    
    /// 值类型的构造器代理
    /// 值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。
    static func initializerDelegationForValueTypesTest() {
        struct SomeStruct {
            var x: Int
            var y: Int
            var z: Int
            init(x: Int, y: Int, z: Int) {
                self.x = x
                self.y = y
                self.z = z
            }
            init(x: Int, y: Int) {
                self.init(x: x, y: y, z: 0) // 代理到 init(x: Int, y: Int, z: Int) 构造器
            }
        }
    }
    
    
    /// 类里面的所有存储型属性，包括所有继承自父类的属性，都必须在构造过程中设置初始值。Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，即指定构造器和便利构造器。
    //  1. 指定构造器是类中最主要的构造器，指定构造器将初始化类中提供的所有属性，并调用合适的父类构造器让构造过程沿着父类链继续往上进行。
    //  2. 每一个类都必须至少拥有一个指定构造器，类倾向于拥有极少的指定构造器，普遍的是一个类只拥有一个指定构造器。
    //  3. 便利构造器是类中比较次要的、辅助型的构造器。可以定义便利构造器来调用同一个类中的指定构造器，并为部分形参提供默认值。
    //  指定构造器的语法跟值类型构造器一样
    //  init(parameters) {
    //      statements
    //  }
    //  便利构造器使用 convenience 修饰
    //  convenience init(parameters) {
    //      statements
    //  }
    
    /// 类类型的构造器代理：指定构造器和便利构造器之间的调用关系遵循以下三条规则：
    //  1. 指定构造器必须调用其直接父类的的指定构造器
    //  2. 便利构造器必须调用同类中定义的其它构造器
    //  3. 便利构造器最后必须调用指定构造器
    //  总结：指定构造器必须总是向上代理，便利构造器必须总是横向代理
    
    /// 两段式构造过程：Swift 中类的构造过程包含两个阶段
    //  1. 为类（父类和子类）中的每个存储型属性设置初始值
    //  2. 给每个类一次机会，在新实例准备使用之前进一步自定义它们的存储型属性
    // 总结：两段式构造过程让构造过程更安全，每个存储属性都保证被设置了初始值，可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值；同时在整个类层级结构中给予了每个类完全的灵活性。
    /// Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程不出错地完成：
    //  1. 指定构造器必须保证它所在类的所有属性都必须先初始化完成，之后才能将构造任务向上代理给父类中的构造器。
    //  2. 指定构造器必须在为继承的属性设置新值之前向上代理调用父类构造器。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。
    //  3. 便利构造器必须为任意属性（包括所有同类中定义的）赋新值之前代理调用其它构造器。如果没这么做，便利构造器赋予的新值将被该类的指定构造器所覆盖。
    //  4. 构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self 作为一个值。类的实例在第一阶段结束以前并不是完全有效的，只有第一阶段完成后，类的实例才是有效的，才能访问属性和调用方法。
    
    static func InitializerDelegationForClassTypes() {
        
    }
}
